// Copyright (c) 2017, Marko Vasic
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.Rocks;
using EkstaziSharp.Util;
using System.Reflection;
using System.Collections.Generic;
using System.Linq;

using EkstaziSharp.Model;
using File = EkstaziSharp.Model.File;

namespace EkstaziSharp.Instrumentation
{
    /// <summary>
    /// This class notifies DependencyMonitor about each class used during program execution
    /// by adding calls to DependencyMonitor in each instance constructor and on each static field access.
    /// </summary>
    /// 

        
    public class InstanceProgramInstrumentator : ProgramInstrumentator
    {

        #region Private Fields
        Dictionary< Int32,String> L = new Dictionary<Int32,string>();
        private Dictionary<string, Dictionary<string, FunctionInfo>> AllAssemblyInfo = new Dictionary<string, Dictionary<string, FunctionInfo>>();
        private IInstrumentationModelBuilderFactory _instrumentationModelBuilderFactory;      
        /// <summary>
        /// Indicates whether method under instrumentation has been modified.
        /// </summary>
        private bool methodModified = false;
        Dictionary<String, List<string>> PathToFile = new Dictionary<string, List<string>>();
        /// <summary>
        /// Represents method currently under instrumentation.
        /// </summary>
        private MethodDefinition methodUnderInstrumentation;

        #endregion

        #region Constructors

        public InstanceProgramInstrumentator(ModuleDefinition moduleToInstrument, InstrumentatorParameters parameters)
            : base(moduleToInstrument, parameters)
        { }

        #endregion

        #region Private Methods

        private bool IsStaticFieldAccess(Instruction instruction)
        {
            return CecilExtensions.StaticAccessInstructions.Contains(instruction.OpCode);
        }

        private bool IsStaticMethodCall(Instruction instruction)
        {
            bool isCall = instruction.OpCode == OpCodes.Call;
            if (!isCall)
            {
                return false;
            }
            MethodReference callee = instruction.Operand as MethodReference;
            return !callee.HasThis;
        }

        private TypeReference GetStaticFieldAccessTarget(MethodDefinition method, Instruction staticFieldAccessInstruction)
        {
            ILProcessor il = method.Body.GetILProcessor();
            FieldReference operand = staticFieldAccessInstruction.Operand as FieldReference;
            TypeReference declaringType = operand.DeclaringType;

            // In a case of types that are autogenerated out of lambda expressions
            // TypeReference does not give same name as TypeDefinition, and GetElementType
            // difference is that TypeReference includes generics parameters, e.g. T
            // For compatibility with Analysis phase, it is needed to use the other name
            return declaringType.GetElementType();
        }

        private TypeReference GetStaticMethodCallTarget(MethodDefinition method, Instruction staticMethodCallInstruction)
        {
            ILProcessor il = method.Body.GetILProcessor();

            //MethodDefinition calle = staticMethodCallInstruction.Operand as MethodDefinition;
            MethodReference callee = staticMethodCallInstruction.Operand as MethodReference;
            // type containing method called used callInstruction
            TypeReference declaringType = callee.DeclaringType;
            // same reason as for GetStaticFieldAccessTarget
            return declaringType.GetElementType();
            //MetadataToken  
        }

        private bool WithinModuleUnderInstrumentation(TypeReference type)
        {
            return NamesOfModulesUnderInstrumentation.Contains(type.Scope.Name);
        }

        /// <summary>
        /// Returns a list of Instruction, Type pairs 
        /// that represent instrumentation point and coresponding type respectively.
        /// If instruction is null than whole method is a dependency
        /// </summary>
        private List<Tuple<Instruction, TypeReference>> GetInstrumentationPoints(MethodDefinition method)
        {
            List<Tuple<Instruction, TypeReference>> instrumentationPoints = new List<Tuple<Instruction, TypeReference>>();

            if (method.Name == CLRConstants.ConstructorName)
            {
                // TODO: can we use method.IsConstructor instead
                instrumentationPoints.Add(new Tuple<Instruction, TypeReference>(null, method.DeclaringType));
            }

            foreach (var instruction in method.Body.Instructions)
            {
                if (IsStaticFieldAccess(instruction))
                {
                    TypeReference type = GetStaticFieldAccessTarget(method, instruction);
                    if (WithinModuleUnderInstrumentation(type))
                    {
                        //instrumentationPoints.Add(new Tuple<Instruction, TypeReference>(instruction, type));
                         instrumentationPoints.Add(new Tuple<Instruction, TypeReference>(null, type));
                    }
                }
                else if (IsStaticMethodCall(instruction))
                {
                    TypeReference type = GetStaticMethodCallTarget(method, instruction);
                    if (WithinModuleUnderInstrumentation(type))
                    {
                        //instrumentationPoints.Add(new Tuple<Instruction, TypeReference>(instruction, type));
                        instrumentationPoints.Add(new Tuple<Instruction, TypeReference>(null, type));
                    }
                }
            }

            return instrumentationPoints;
        }

        private void InstrumentAtPoints(MethodDefinition method, List<Tuple<Instruction, TypeReference>> instrumentationPoints)
        {
            if (instrumentationPoints.Count == 0)
            {
                return;
            }

            method.Body.SimplifyMacros();
            foreach (var pair in instrumentationPoints)
            {
                Instruction instruction = pair.Item1;
                TypeReference dependency = pair.Item2;
                if (instruction == null)
                {
                     InsertCallToDependencyMonitor(method, TMethod, dependency,PathToFile);
                }
                else
                {
                     InsertCallToDependencyMonitor(method, instruction, TMethod, dependency,PathToFile);
                }
            }
            method.Body.OptimizeMacros();
        }

        private void InstrumentAtMethodBeginning(MethodDefinition method, List<Tuple<Instruction, TypeReference>> instrumentationPoints)
        {
            if (instrumentationPoints.Count == 0)
            {
                return;
            }

            List<TypeReference> uniqueDependencies = new List<TypeReference>();
            HashSet<string> dependencyNames = new HashSet<string>();

            foreach (var tuple in instrumentationPoints)
            {
                TypeReference type = tuple.Item2;
                string dependencyName = $"{type.Module.Name}{type.FullName}";
                if (!dependencyNames.Contains(dependencyName))
                {
                    dependencyNames.Add(dependencyName);
                    uniqueDependencies.Add(type);
                }
            }

            foreach (var dependency in uniqueDependencies)
            {
                InsertCallToDependencyMonitor(method, TMethod, dependency);
            }
        }

        #endregion

        #region Public Methods
        
        public EkstaziSharp.Model.Module TrackAssembly(string modulePath, string assemblyName)
        {
            _instrumentationModelBuilderFactory = new InstrumentationModelBuilderFactory();
            var builder = _instrumentationModelBuilderFactory.CreateModelBuilder(modulePath, assemblyName);
            EkstaziSharp.Model.Module module = builder.BuildModuleModel();
            SaveModule(module);
            return module;
        }
        //for the mapping, saved in PathToFile. FunctionName and FunctionFile 
        private void SaveModule(EkstaziSharp.Model.Module module)
        {
            if (module.FullName.Contains("National") || module.FullName.Contains("national"))
            {
                var files = module.Files;
                foreach (var c in module.Classes)
                {
                    List<String> PathOFclass = new List<string>();
                    foreach (var m in c.Methods)
                    {
                        FunctionInfo newFunc = new FunctionInfo();
                        newFunc.functionToken = m.MetadataToken.ToString();
                        newFunc.functionName = m.Name;
                        if (m.FileRef != null)
                        {
                            newFunc.functionFileReference = module.Files.Where(s => s.UniqueId == m.FileRef.UniqueId).First().FullPath;
                        }
                        var val = L[m.MetadataToken];
                        if (!PathOFclass.Contains(newFunc.functionFileReference) && newFunc.functionFileReference != null)
                            PathOFclass.Add(newFunc.functionFileReference);   
                      //  if (!PathToFile.ContainsKey(val)&&newFunc.functionFileReference!=null )
                       //     PathToFile.Add(c.FullName, newFunc.functionFileReference);

                        //if (PathToFile.ContainsKey(argumentToDependencyMonitor.FullName))
                        //{
                        //    PathToFile.Add(newFunc.functionName, newFunc.functionFileReference);
                        //}
                        //if (!PathToFile.ContainsKey(newFunc.functionName))
                        //    PathToFile.Add(newFunc.functionName,newFunc.functionFileReference);
                        ///*
                        //else
                        //    Console.WriteLine(F[newFunc.functionName].functionFileReference, newFunc.functionFileReference);
                        //*/
                    }
                    if(PathOFclass.Count!=0)
                    PathToFile.Add(c.FullName, PathOFclass);
                }
            }

        }


        //public void Extra()
        //{
        //    int c = 0;

        //    foreach (TypeDefinition type in moduleToInstrument.GetTypes(includeNestedTypes: true))
        //    {
        //        foreach (MethodDefinition method in type.Methods)
        //        {
        //            if (!L.ContainsKey(method.DeclaringType.FullName))
        //                L.Add(method.DeclaringType.FullName, method.MetadataToken);
        //            else
        //                c++;
        //            if (method is TypeReference)
        //            {
        //                L.Add(method.FullName, method.MetadataToken); 
        //            }
        //            else if (method is MethodReference)
        //            {
        //               // L.Add(method$"{method.DeclaringType.FullName}.{method.Name}", method.MetadataToken);
        //            }
        //        }
        //    }
        //}
        public void Extra()
        {
            int c = 0;

            foreach (TypeDefinition type in moduleToInstrument.GetTypes(includeNestedTypes: true))
            {
                if (type.DeclaringType!=null)
                    ;
                foreach (MethodDefinition method in type.Methods)
                {
                    if (!L.ContainsKey(method.MetadataToken.ToInt32()))
                        L.Add(method.MetadataToken.ToInt32(),method.DeclaringType.FullName );
                    else
                        c++;
                    
                }
            }
           // Extra2();
        }

        public override void Instrument()
        {
            Extra();
            //Added part for the mapping of the FunctionName to the FilePath
            TrackAssembly(moduleToInstrument.FullyQualifiedName, "");
            // TODO: Experiment with parallelizing following loops
            foreach (TypeDefinition type in moduleToInstrument.GetTypes(includeNestedTypes: true))
            {
                foreach (MethodDefinition method in type.Methods)
                {
                    if (!method.HasBody)
                    {
                        // TODO: check if you need to instrument constructors that have no body
                        // and in which cases constructors do not have body
                        continue;
                    }

                    List<Tuple<Instruction, TypeReference>> instrumentationPoints = GetInstrumentationPoints(method);

                    if (!parameters.InstrumentAtMethodBeginning)
                    {
                        InstrumentAtPoints(method, instrumentationPoints);
                    }
                    else
                    {
                        InstrumentAtMethodBeginning(method, instrumentationPoints);
                    }
                }
            }
        }

        #endregion
    }
}
